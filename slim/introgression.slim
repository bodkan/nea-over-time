initialize() {
    initializeRecombinationRate($recomb_rates, $recomb_ends);
    initializeMutationRate($mut_rate);

    // deleterious mutation type
    if ($fixed_s) {
        initializeMutationType("m0", $dominance_coef, "f", $fixed_s);
    } else {
        initializeMutationType("m0", $dominance_coef, "g", -0.043, 0.23);
    }

    // mutation type of exonic neutral markers
    initializeMutationType("m1", 0.5, "f", 0.0);
    m1.convertToSubstitution = F;

    // mutation type of non-exonic neutral markers
    initializeMutationType("m2", 0.5, "f", 0.0);
    m2.convertToSubstitution = F;

    initializeGenomicElementType("g1", m0, 1.0);

    $genomic_elements

    // positions of the fixed Neanderthal neutral markers
    defineConstant("exonic_pos", $exonic_pos);
    defineConstant("nonexonic_pos", $nonexonic_pos);

    defineConstant("trajectories_gen", sort(unique(c($sampling_times,
                                                     seq(1, 100) + $admixture_time - 1,
                                                     seq(120     + $admixture_time - 1, $sim_length, 20),
						     $sim_length))));

    defineConstant("dump_gen", unique(c(seq(1, 50) + $admixture_time - 1,
                                        seq(100    + $admixture_time - 1, $sim_length, 300),
				        $sim_length)));

    defineConstant("simulate_dilution", $simulate_dilution);
    defineConstant("single_pulse", $admixture_time == $admixture_end);

    defineConstant("tmp_file", "tmp/tmp" + getSeed() + ".txt");
}

// load the simulation state after the out of Africa event
1 {
    cat(time() + " :: INFO :: Reading populations.\n");
    sim.readFromPopulationFile("$population_file");
    sim.generation = 1;

    // delete the African population when not simulating dilution
    if (!simulate_dilution) {
        p1.setSubpopulationSize(0);
    }
}

// save the simulation state right before the admixture in case it is
// necessary to restart (makes sense just for the single pulse scenario)
$before_admixture late() {
    if (single_pulse) {
        cat(time() + " :: INFO :: Saving the simulation state before the admixture\n");
        sim.outputFull(tmp_file);
    }
}

// Neanderthal admixture
$admixture_time {
    cat(time() + " :: INFO :: Starting the admixture.\n");
    p3.setMigrationRates(p2, $admixture_rate);
}

// make sure the simulated population received enough Neanderthal gene flow
// (makes sense just for the single pulse scenario)
$admixture_time late() {
    if (single_pulse) {

    exonic_count = p3.genomes.countOfMutationsOfType(m1);
    nonexonic_count = p3.genomes.countOfMutationsOfType(m2);
    total = size(exonic_pos) + size(nonexonic_pos);

    mean_nea = sum(exonic_count + nonexonic_count) / (2 * p3.individualCount) / total;

    if (abs(mean_nea - $admixture_rate) > ($admixture_rate * 0.025)) {
        cat(time() + " :: INFO :: Simulated gene flow NOT accepted (" + mean_nea + ") - restarting.\n");
        sim.readFromPopulationFile(tmp_file);
        sim.generation = $before_admixture;
        setSeed(getSeed() + 1);
    } else {
        cat(time() + " :: INFO :: Simulated gene flow accepted (" + mean_nea + ") - continuing.\n");
        deleteFile(tmp_file);
    }

    }
}

// end the Neanderthal admixture by deleting the Neanderthal population
$after_admixture {
    cat(time() + " :: INFO :: Ending the admixture, removing Neanderthals.\n");
    p2.setSubpopulationSize(0);
}

// output Nea. ancestry trajectories calculated on exonic sites
$admixture_time:$sim_length late() {
    output_file = "$output_prefix" + "__exonic_sites.txt";

    if ($save_trajectories & any(sim.generation == trajectories_gen)) {
        cat(time() + " :: INFO :: " + sim.generation + "/$sim_length generations\n");

        nea_per_ind = apply(seq(0, p3.individualCount - 1),
                            "sum(p3.genomes[c(2 * applyValue, 2 * applyValue + 1)].countOfMutationsOfType(m1));") / (2 * size(exonic_pos));

        if (sim.generation == $admixture_time)
            writeFile(output_file, "gen\tmean\tsd\tmedian\tmin\tmax\tNe\n");

            writeFile(output_file, paste(c(sim.generation - $admixture_time + 1,
                                           mean(nea_per_ind),
                                           sd(nea_per_ind),
                                           sort(nea_per_ind)[asInteger(size(nea_per_ind) / 2)],
                                           min(nea_per_ind),
                                           max(nea_per_ind),
                                           p3.individualCount), "\t") + "\n",
                      append=T);
  }
}

// output Nea. ancestry trajectories calculated on non-exonic sites
$admixture_time:$sim_length late() {
    output_file = "$output_prefix" + "__nonexonic_sites.txt";

    if ($save_trajectories & any(sim.generation == trajectories_gen)) {
        nea_per_ind = apply(seq(0, p3.individualCount - 1),
                            "sum(p3.genomes[c(2 * applyValue, 2 * applyValue + 1)].countOfMutationsOfType(m2));") / (2 * size(nonexonic_pos));

        if (sim.generation == $admixture_time)
            writeFile(output_file, "gen\tmean\tsd\tmedian\tmin\tmax\tNe\n");

            writeFile(output_file, paste(c(sim.generation - $admixture_time + 1,
                                           mean(nea_per_ind),
                                           sd(nea_per_ind),
                                           sort(nea_per_ind)[asInteger(size(nea_per_ind) / 2)],
                                           min(nea_per_ind),
                                           max(nea_per_ind),
                                           p3.individualCount), "\t") + "\n",
                      append=T);
  }
}

// save the simulation states at defined timepoints
$admixture_time:$sim_length late() {
    if ($save_mutations & any(sim.generation == dump_gen)) {
        sim.outputFull("$output_prefix" + "__dump_gen_" + asString(sim.generation - $admixture_time + 1) + ".txt");
    }
}