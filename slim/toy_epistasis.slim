// set up a simple neutral simulation
initialize() {
    defineConstant("DEBUG", F);

    // defineConstant("EPI_PAIRS", 10);
    // defineConstant("EPI_S", 0.0);
    // defineConstant("EPI_REC", 1e-8);
    // defineConstant("INIT_F", 0.1);

    defineConstant("POP_SIZE", 500);

    defineConstant("epi_pos", seq(0, 2 * EPI_PAIRS - 1));

    initializeMutationRate(0);
        
    // mutation type of epistatically-interacting alleles (neutral before
    // they are "orphaned" by recombination)
    initializeMutationType("m1", 1.0, "f", 0.0);

    // simulate only the epistatically-interacting sites
    initializeGenomicElementType("g1", m1, 1.0);
    initializeGenomicElement(g1, 0, EPI_PAIRS * 2 - 1);

    // use a fixed recombination between epistatic alleles, but free recombination between pairs
    rec_rates = ifelse(seq(1, 2 * EPI_PAIRS - 1) % 2 != 0, EPI_REC, 0.5);
    rec_ends = seq(1, 2 * EPI_PAIRS - 1);
    initializeRecombinationRate(rec_rates, rec_ends);

    if (DEBUG) {
        for (i in seq(0, size(rec_rates) - 1)) {
            cat(rec_rates[i] + "\t" + rec_ends[i] + "\n");
        }
    }
}


1 {
    sim.addSubpop("p1", POP_SIZE);

    // calculate the total number of introgressed haplotypes in the founding
    // population, given the ancestry proportion in the F1 generation
    intro_haps_count = asInteger(2 * POP_SIZE * INIT_F);

    // extract the F1 introgressed haplotypes
    intro_haps = p1.genomes[seq(0, 2 * intro_haps_count - 2, 2)];

    // place the epistatically interacting allele pairs on the haplotypes,
    // and assign tags to them (these identify epistatic pairs)
    for (i in seqAlong(epi_pos)) {
        mut = intro_haps.addNewDrawnMutation(m1, epi_pos[i]);
        mut.tag = asInteger(i / 2) + 1;
    }

    if (DEBUG) {
        for (i in seqAlong(epi_pos)) {
            mut = sim.mutations[sim.mutations.position == epi_pos[i]];
            cat("site # " + mut.position + " assigned tag " + mut.tag + "\n");
        }
        cat("Total number of epistatic loci: " + sim.countOfMutationsOfType(m1) + "\n");
    }
}


1:1001 {
    if (sim.generation == 1) writeFile(OUTPUT, "gen\tf\tinit_f\ts\tr\n");

    if (sim.generation == 1 | sim.generation % 25 == 0) {
        intro_f = sum(p1.genomes.countOfMutationsOfType(m1)) / (2 * POP_SIZE * size(epi_pos));
        writeFile(OUTPUT, sim.generation + "\t" + intro_f + "\t" + INIT_F + "\t" + EPI_S + "\t" + EPI_REC + "\n", append=T);
    }

    if (DEBUG) {
        print("generation " + sim.generation);
        for (ind in p1.individuals) {
            cat("individual ");
            cat(ind);
            cat("\ngenome 1:\t");
            cat(ind.genomes[0].countOfMutationsOfType(m1));
            cat("\tgenome 2:\t");
            cat(ind.genomes[1].countOfMutationsOfType(m1));
            cat("\n");
        }
    }
}


// check for the presence of broken epistatic pairs, making orphaned
// mutations deleterious
modifyChild() {
    // get all mutations in this child
    genome1_muts = childGenome1.mutationsOfType(m1);
    genome2_muts = childGenome2.mutationsOfType(m1);

    // check for broken-up epistatic pairs
    for (i in seq(1, size(epi_pos) / 2)) {
        // get the i-th epistatic pair on both genomes
        genome1_pair = genome1_muts[genome1_muts.tag == i];
        genome2_pair = genome2_muts[genome2_muts.tag == i];
        
        // there is only 1 mutation from the original pair left on the first genome
        if (size(genome1_pair) == 1) {
            orphan = genome1_pair[0];

            // remove this mutation from the genome
            childGenome1.removeMutations(orphan);

            // add a new mutation at it's position, with a given value of the selection coefficient
            childGenome1.addNewMutation(orphan.mutationType, -EPI_S, orphan.position);
        }

        // there is only 1 mutation from the original pair left on the second genome
        if (size(genome2_pair) == 1) {
            orphan = genome2_pair[0];

            // remove this mutation from the genome
            childGenome2.removeMutations(orphan);

            // add a new mutation at it's position, with a given value of the selection coefficient
            childGenome2.addNewMutation(orphan.mutationType, -EPI_S, orphan.position);
        }
    }

    return T;
}
