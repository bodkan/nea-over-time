// set up a simple neutral simulation
initialize() {
    defineConstant("debug", T);

    // defineConstant("EPI_PAIRS", 10);
    // defineConstant("EPI_S", 0.0);
    // defineConstant("RECOMB", 1e-8);
    // defineConstant("INIT_F", 0.1);
    defineConstant("POP_SIZE", 5000);

    defineConstant("epi_pos", seq(0, 2 * EPI_PAIRS - 1));

    initializeMutationRate(0);
        
    // mutation type of epistatically-interacting neutral alleles
    // (before being orphaned by recombination - will be deleterious after that)
    initializeMutationType("m1", 0.5, "f", 0.0);

    // simulate only the epistatically-interacting sites, with a given rate of
    // recombination in between
    initializeGenomicElementType("g1", m1, 1.0);
    initializeGenomicElement(g1, 0, EPI_PAIRS * 2 - 1);
    initializeRecombinationRate(RECOMB);
}

1 {
    sim.addSubpop("p1", POP_SIZE);

    // calculate the total number of Neanderthal haplotypes in
    // the founding population so we get an appropriate frequency
    // of Neanderthal alleles
    nea_haps_count = asInteger(2 * POP_SIZE * INIT_F);
    
    // extract the Neanderthal haplotypes
    nea_haps = p1.genomes[seq(0, 2 * nea_haps_count - 2, 2)];

    // then assign tags to the epistatically interacting allele pairs
    for (i in seqAlong(epi_pos)) {
        mut = nea_haps.addNewDrawnMutation(m1, epi_pos[i]);
        mut.tag = asInteger(i / 2) + 1;
    }

    // if (debug) {
    //     for (i in seqAlong(epi_pos)) {
    //         mut = sim.mutations[sim.mutations.position == epi_pos[i]];
    //         cat(mut.position + " assigned " + mut.tag + "\n");
    //     }
    //     cat("Total number of epistatic loci: " + sim.countOfMutationsOfType(m1) + "\n");
    // }
    sim.simulationFinished();
}

modifyChild() {
    // get all mutations in this child
    genome1_muts = childGenome1.mutationsOfType(m1);
    genome2_muts = childGenome2.mutationsOfType(m1);

    // check for broken-up epistatic pairs
    for (i in seq(1, size(epi_pos) / 2)) {
        // get the i-th epistatic pair on both genomes
        genome1_pair = genome1_muts[genome1_muts.tag == i];
        genome2_pair = genome2_muts[genome2_muts.tag == i];
        
        // there is only 1 mutation from the original pair left on the first genome
        if (size(genome1_pair) == 1) {
            orphan = genome1_pair[0];

            // remove this mutation from the genome
            childGenome1.removeMutations(orphan);

            // add a new mutation at it's position, with a given value of the selection coefficient
            childGenome1.addNewMutation(orphan.mutationType, -EPI_S, orphan.position);
        }

        // there is only 1 mutation from the original pair left on the second genome
        if (size(genome2_pair) == 1) {
            orphan = genome2_pair[0];

            // remove this mutation from the genome
            childGenome2.removeMutations(orphan);

            // add a new mutation at it's position, with a given value of the selection coefficient
            childGenome2.addNewMutation(orphan.mutationType, -EPI_S, orphan.position);
        }
    }
    return T;
}

3:1000 {
    if (sim.generation == 1) writeFile(OUTPUT, "gen\tprop\n");

    prop = sum(p1.genomes.countOfMutationsOfType(m1)) / (2 * POP_SIZE * size(epi_pos));
    writeFile(OUTPUT, sim.generation + "\t" + prop + "\n", append=T);

    // for (ind in p1.individuals) {
    //     cat("individual ");
    //     cat(ind);
    //     cat("\ngenome 1:\t");
    //     cat(ind.genomes[0].countOfMutationsOfType(m1));
    //     cat("\tgenome 2:\t");
    //     cat(ind.genomes[1].countOfMutationsOfType(m1));
    //     cat("\n");
    // }
}