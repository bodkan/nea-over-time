initialize() {
    initializeRecombinationRate(1e-8);
    initializeMutationRate(7e-9);

    // deleterious mutation types
    initializeMutationType("m1", 0.5, "g", -0.043, 0.23);
    initializeMutationType("m2", 0.1, "g", -0.043, 0.23);
    initializeMutationType("m3", 0.0, "g", -0.043, 0.23);

    // mutation type of neutral markers
    initializeMutationType("m0", 0.5, "f", 0.0);
    m0.convertToSubstitution = F;

    // define the proportions of different types of deleterious alleles
    initializeGenomicElementType("g1", c(m1, m2, m3), c(prop_add, prop_partrec, prop_rec));

    initializeGenomicElement(g1, 0, segment_length);

    // positions of the fixed Neanderthal neutral markers
    defineConstant("neutral_pos", seq(0, segment_length, neutral_spacing));

    defineConstant("tmp_file", "tmp/tmp" + getSeed() + ".txt");
}

// load the simulation state after the out of Africa event
1 {
    cat(time() + " :: INFO :: Reading populations.\n");
    sim.readFromPopulationFile("simulations/dominance_mix__" + prop_add + "_" + prop_partrec +"_" + prop_rec + ".txt");
    sim.generation = 1;

    // out of Africa bottleneck
    p1.setSubpopulationSize(2000);
}

// save the simulation state right before admixture in case it is
// necessary to restart
1 late() {
    cat(time() + " :: INFO :: Saving the simulation state before the admixture\n");
    sim.outputFull(tmp_file);
}

// start of the Neanderthal admixture
2 {
    cat(time() + " :: INFO :: Setting up migration.\n");
    p1.setMigrationRates(p2, 0.1);
}

// make sure the simulated population received enough Neanderthal gene flow
2 late() {
    neutral_count = p1.genomes.countOfMutationsOfType(m0);

    mean_nea = sum(neutral_count) / (2 * p1.individualCount) / size(neutral_pos);

    if (abs(mean_nea - 0.1) > (0.1 * 0.025)) {
        cat(time() + " :: INFO :: Simulated gene flow NOT accepted (" + mean_nea + ") - restarting.\n");
        sim.readFromPopulationFile(tmp_file);
        setSeed(getSeed() + 1);
    } else {
        cat(time() + " :: INFO :: Simulated gene flow accepted (" + mean_nea + ") - continuing.\n");
        deleteFile(tmp_file);
        p2.setSubpopulationSize(0);
    }
}

// output Nea. ancestry trajectories calculated on exonic sites
2:301 late() {
    output_file = "simulations/dominance_mix/constant__" + prop_add + "_" + prop_partrec +"_" + prop_rec + ".txt";

    cat(time() + " :: INFO :: " + sim.generation + "/301 generations\n");

    nea_per_ind = apply(seq(0, p1.individualCount - 1),
                        "sum(p1.genomes[c(2 * applyValue, 2 * applyValue + 1)].countOfMutationsOfType(m0));") / (2 * size(neutral_pos));

    if (sim.generation == 2) {
        writeFile(output_file, "gen\tmean\tsd\tmedian\tmin\tmax\tNe\n");
    }

    writeFile(output_file, paste(c(sim.generation - 1,
                                   mean(nea_per_ind),
                                   sd(nea_per_ind),
                                   sort(nea_per_ind)[asInteger(size(nea_per_ind) / 2)],
                                   min(nea_per_ind),
                                   max(nea_per_ind),
                                   p1.individualCount), "\t") + "\n",
              append=T);
}
